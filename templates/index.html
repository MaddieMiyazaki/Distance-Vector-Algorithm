<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
        <title>DV simulator</title>

        <script
                type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
        </script>
    </head>


<body>
<!--two dark grey sections against a black background-->

<!--First section: header and explanation-->
    <div class="div1">
        <h1>Distance Vector Algorithm</h1>
        <br>
        The Distance Vector algorithm is used to calculate the least-cost path between nodes within a weighted graph.

        Unlike <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra's algorithm</a>  which assumes that each node has a complete topology of the graph, this routing algorithm operates with a more limited view: nodes are only aware of link costs to adjacent neighbours and utilises iterative processes to learn and exchange information about the rest of the graph to recursively improve their understanding of the least-cost paths.
        <br><br>
        Of course, this decentralised approach means that convergence - the state where no further updates occur across any nodes - is much slower than algorithms that assume complete topology awareness.

        <br><br><br>
        <div class="inner-div">
        Given a weighted graph with \(n\) nodes, the algorithm is as follows:
        <ul>
            <li>
                Initially, each node \(x\) will only know their own \(n\)-dimensional distance vector, which is defined as follows:
                $$D_x(y)=
                    \begin{cases}
                    0 & \text{if } x=y \\
                    c(x,y) & \text{link cost if } (x,y) \text{ is an immediate neighbour} \\
                    \infty & \text{otherwise}
                    \end{cases}$$
            </li>

            <li>
                Periodically, each node shares its distance vector with its immediate neighbours.
            </li>
            <li>
                Apply the Bellman-Ford equation. Each destination \(x\) updates its own distance vector as:
                $$D_x (y) = \min_{v\in N(x)} \{c(x,v) + D_v (y) \}$$ where \(N(x)\) is the set of immediate neighbours of \(x\)
            </li>
            <li>
                Updates trigger DV to be shared to immediate neighbours. Repeat until convergence.
            </li>
        </ul>
        </div>
        <br><br>
        When a node discovers a better route - a shorter path - to a destination, this algorithm immediately updates its own distance vector and notifies its neighbours. However, it is important to note that link failures or increases in link costs propagate more slowly through the network, as the algorithm inherently does not reflect these changes immediately. In other words: 'good news travels fast, bad news travels slow'
        <br><br>
        A consequence of the asynchronous nature of this algorithm is that link failures can also lead to a phenomenon called the
        <a href="https://www.geeksforgeeks.org/route-poisoning-and-count-to-infinity-problem-in-routing/">count to infinity problem</a>: nodes may increment their cost to a destination indefinitely, unable to recognise that the destination is unreachable and this can cause large-scale instability across the network.




        <br> <br>
<!--        To do:-->
<!--        <br>-->
<!--        - done: if 'directed' button clicked, double-sided arrow ↔ becomes right arrow →-->
<!--        <br>-->
<!--        - done: add 'clear input' and 'remove link' button - use JavaScript to clear-->
<!--        <br>-->
<!--        - done: turn div3 into sideways scrollable element-->
<!--        <br>-->
<!--        - done: remove trailing zeros in table-->
<!--        <br>-->
<!--        - done: css tables: space out and colour-->
<!--        <br>-->
<!--        - done: 'directed' functionality needs to be fixed-->
<!--        <br>-->
<!--        - done: put directed checkbox inside a button. make checkbox and arrows respond to button click-->
<!--        <br>-->
<!--        - done: add DV explanation: use MathJax-->
<!--        <br>-->
<!--        - make form elements stay upon submission-->
<!--        <br>-->
<!--        - upon submission, don't scroll back to top of page-->
<!--        <br>-->
<!--        - add instructions-->
<!--        <br>-->
<!--        - test edge cases or impossible cases (same link two different costs)-->
<!--        <br>-->
<!--        - remove this to do list!-->
<!--        <br>-->
<!--        Optional:-->
<!--        <br>-->
<!--        - add node names along left of div3-->
<!--        <br>-->
<!--        - hover element with calculation (use latex?)-->
<!--        <br>-->
<!--        - allow user to choose from templates-->
    </div>
    <br>

<!--Second section with interactive part-->
    <div class="div2">
        This simulator performs the distance vector algorithm on directed or undirected graphs.
        It assumes that all distance vectors are sent to immediate neighbours at the same time, and thus updates are performed simultaneously.
        <br><br>
        For an undirected graph, only one entry per link is necessary.
        <br><br>
        For a directed graph, an entry per 'direction' is required. Hence, if it is possible to traverse a link in both directions, two entries are required.
        <br><br>

        <form action="">
            <button type='button' onclick='addLink()'>Add another link</button>
            <button type='button' onclick='RemoveLink()'>Remove last link</button>
            <button type='button' onclick='clearFields()'>Clear all fields</button>
        </form>

        <form id='calculate' method="post" action="{{ url_for('tables') }}" >

<!--            class is for css styling, name is for accessing in dv.py, id is for accessing onclick-->
<!--            type=button is necessary otherwise clicking will take user to tables endpoint automatically-->
            <button type="button" onclick="document.getElementById('directed').click()">
                Directed graph:
                <input type="checkbox" class="directed" name="directed" id="directed" onclick="ChangeArrow()">
            </button>
            <br>

            <div id='section'>

                <input type="text" name="dynamic_input"  class='link' placeholder="Node" value="x">
                <span class="arrow">↔</span>
                <input type="text" name="dynamic_input"  class='link' placeholder="Node" value="y">
                <input type="text" name="dynamic_input"  class='link' placeholder="Cost" value="1">
                <br>
                <input type="text" name="dynamic_input"  class='link' placeholder="Node" value="y">
                <span class="arrow">↔</span>
                <input type="text" name="dynamic_input"  class='link' placeholder="Node" value="z">
                <input type="text" name="dynamic_input"  class='link' placeholder="Cost" value="2">
                <br>
                <input type="text" name="dynamic_input" class='link' placeholder="Node" value="z">
                <span class="arrow">↔</span>
                <input type="text" name="dynamic_input" class='link' placeholder="Node" value="x">
                <input type="text" name="dynamic_input" class='link' placeholder="Cost" value="7">
                <br>
            </div>

            <br>
            <button type="submit">Calculate distance vectors</button>
        </form>
    </div>
<br>

{% block content %}{% endblock %}




    <script>

        // upon checking/unchecking 'Directed graph' box, toggle all arrows
        function ChangeArrow() {
            let arrowList=document.getElementsByClassName('arrow')                 // list (HTML collection) of all arrows
            let newArrow = (arrowList[0].textContent === '↔') ? '→' : '↔';        //ternary operator: if (the first) arrow is double-sided, switch to rightrrow and vice versa
            for (let a of arrowList) {                                            // use 'of' instead of 'in' since arrowList is not a list but an HTML collection
                a.textContent=newArrow                                            //assign the new arrow to each arrow using for loop
            }
        }

        //upon clicking the button 'Add another link', add three forms (node,arrow,node,cost)
        //assign all new Inputs to class 'link' for CSS
        //assign all new Inputs to name 'dynamic_input' to add to list for dv.py
        //and append all to 'section' - ie underneath the original links
        //line break between each new link
        function addLink() {
            const newInput1=document.createElement('input')
            newInput1.className='link'
            newInput1.name='dynamic_input'
            newInput1.placeholder='Node'
            document.getElementById('section').appendChild(newInput1)

            // by default, arrow is double-sided
            // assign to class 'arrow' to allow for switching to rightarrow upon button click
            const arrow=document.createElement('span')
            arrow.textContent='↔'
            arrow.className='arrow'
            document.getElementById('section').appendChild(arrow)

            const newInput2=document.createElement('input')
            newInput2.className='link'
            newInput2.name='dynamic_input'
            newInput2.placeholder='Node'
            document.getElementById('section').appendChild(newInput2)

            const newInput3=document.createElement('input')
            newInput3.className='link'
            newInput3.name='dynamic_input'
            newInput3.placeholder='Cost'
            document.getElementById('section').appendChild(newInput3)

            const lineBreak = document.createElement('br')
            document.getElementById('section').appendChild(lineBreak)
            }


        function RemoveLink() {
            let allLinks=document.getElementsByClassName('link')
            for (let i=1;i<4;i++) {
                allLinks[allLinks.length-1].remove()
            }
            let allArrows=document.getElementsByClassName('arrow')
            allArrows[allArrows.length-1].remove()
        }

        // get elements by tag returns all <input> elements as an HTMl collection so first turn into array
        // then loop through each element, setting its value to empty string
        // using this shorthand function (input => input.value = '')
        function clearFields() {
            [...document.getElementsByTagName('input')].forEach(input => input.value = '');
        }


    </script>

</body>

</html>